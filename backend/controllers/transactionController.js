const Transaction = require("../models/transaction");
const User = require("../models/user");
const Book = require("../models/book");

// Issueing a book

exports.issueBook = async (req, res) => {
  const { bookId, userId, issueDate } = req.body;

  const user = await User.findById(userId);
  if (!user) return res.status(400).json({ error: "User not found" });

  try {
    const transaction = new Transaction({ bookId, userId, issueDate });
    await transaction.save();
    return res.json({
      transaction,
      message: "Book issued successfully",
      success: true,
    });
  } catch (error) {
    res.status(500).json({ message: error.message });
  }

  const book = await Book.findById(bookId);
  if (!book) return res.status(400).json({ error: "Book not found" });
};

// Return book and calcuating rent

exports.returnBook = async (req, res) => {
  const { transactionId, returnDate } = req.body;

  try {
    const transaction = await Transaction.findById(transactionId);
    if (!transaction) {
      return res.status(400).json({ error: "Transaction not found" });
    }

    const daysRented =
      (new Date(returnDate) - new Date(transaction.issueDate)) /
      (1000 * 60 * 60 * 24);

    const book = await Book.findById(transaction.bookId);
    if (!book) {
      return res.status(400).json({ error: "Book not found" });
    }
    const totalRent = daysRented * book.rentperday;

    transaction.returnDate = returnDate;
    transaction.totalRent = totalRent;
    transaction.status = "returned";

    await transaction.save();

    res.json(transaction);
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
};

// Get transaction for specific (one) book

exports.getTransactionsByBook = async (req, res) => {
  const { bookId } = req.query;

  try {
    const transactions = await Transaction.find({ bookId }).populate(
      "userId",
      "name"
    );
    const currentlyIssued =
      transactions.filter((t) => !t.returnDate)[0] || null;

    res.json({
      transactions,
      totalCount: transactions.length,
      currentlyIssued,
    });
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
};

// Calculating total rent generated by a book

exports.getTotalRentByBook = async (req, res) => {
  const { bookId } = req.query;
  try {
    const transactions = await Transaction.find({ bookId });
    const totalRent = transactions.reduce(
      (sum, t) => sum + (t.totalRent || 0),
      0
    );
    res.json({ totalRent });
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
};

// Get active transactions (those that haven't been returned)
exports.getActiveTransactions = async (req, res) => {
  try {
    const activeTransactions = await Transaction.find({
      returnDate: null,
    }).populate("bookId", "title");
    res.json(activeTransactions);
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
};
// fatch record of all transactions
exports.Record = async (req, res) => {
  try {
    const record = await Transaction.find();
    res.json(record);
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
};
